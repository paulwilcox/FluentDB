import * as g from "./general.js";
import { parser } from './parser.js';
//import { hashBuckets } from "./hashBuckets.js";
//import { joiner } from "./join.js";
//import { quicksort } from "./sorts.js";
import { database } from "./database";
//import { addStaticFolds } from "./folds.js";
import { mapCore } from "./map.js";
//import { print } from "./visualizer/printer.js";
import { dsGetter } from "./dsGetter.js";
//import { mergeIntoIdb, mergeIntoDataset } from "./merge.js";
import { dbConnector } from './dbConnector.js';
import { dbConnectorIdb } from "./dbConnectorIdb.js";
import { deferable } from "./deferable.js";

export let $$ = obj => new oneQuery(obj);

export class oneQuery extends deferable { 

    this.print = (mappingFunction, target, caption) => {

        this.executeAll();

        let aliases = new g.parser(mappingFunction).parameters;

        // Just print the idbdataset as a whole.
        if (Object.keys(this.externalDbs).includes(aliases[0])) {
            
            let externalDb = this.externalDbs[aliases[0]];
            let datasetName = mappingFunction();

            if (externalDb.dbType == 'idb')
                printIdbStore(datasetName, externalDb.database, target, caption);

            return this;

        }

        let dataset = this.getDataset(aliases);
        dataset = dataset.then(dataset => {
            print(target, mappingFunction(dataset), caption);
            return dataset;
        });

        return this;

    }

    let printIdbStore = (storeName, database, target, caption) => 

        database
        .then(db => {
            let tx = db.transaction(storeName);
            let store = tx.objectStore(storeName);
            return store.getAll();
        })
        .then(store => {
            print(target, store, caption);
        });

    this.merge = (
        target, // if string for an idbdataset, updates the idbObjectdataset, otherwise, updates the oneQuerydataset 
        source, // mapper function or maybe even direct array of objects  
        identityKey,
        action = () => oneQuery.mergeAction.upsert // function returning a oneQuery.mergeAction (or the direct string)
    ) => {

        let srcAliases = new g.parser(source).parameters;

        let literalizedSource = 
            this.literalizeIfNecessary(source);

        let mc = mapCore(literalizedSource, new Set(srcAliases), this);

        if (!g.isFunction(target)) {

            let targetDatasetMerged = 
                pretendPromise.all([mc, this.getDataset(target)])
                .then(obj => { 
                    let mapped = obj[0];
                    let targetDataset = obj[1];
                    let mergedTarget = mergeIntoDataset(targetDataset, mapped, identityKey, action);
                    return mergedTarget;
                })
                .execute();

            this.database.addDatasets(
                target, 
                new pretendPromise(targetDatasetMerged)
            );

        }

        else {

            let externalDb = this.externalDbs[new g.parser(target).parameters[0]];

            if (externalDb.dbType == 'idb') 
                
                // Why did I (psw) have to wrap in pretend promise to work?
                pretendPromise.all([mc]) 
                .then(obj => {
                    let mapped = obj[0];
                    mergeIntoIdb(externalDb.database, target(), mapped, identityKey, action);
                });

        }

        return this;

    }

*/
}

/*
oneQuery.mergeAction = Object.freeze({
    nothing: null,
    upsert: 'upsert',
    remove: 'remove'
})
*/

