<body>
<pre id="result"></pre>

<script type="module">

    // TODO:    - Null and undefined handling
    //              > default and seed are not the same thing
    //              > have aggs use first non-null/undefined value
    //              > instead of depending on seed, unless 
    //                explicitly desired.
    //          - Can we return aggregator.data, but in a way that 
    //            all aggregator.datas are joined together?
    //          - Formalize pluging in new functions.

    class aggregator {

        constructor() {
            this.data = [];
            this.aggregation;
            this.steps = [];
        }

        loadValue(value) {
            this.data.push(value);
        }

        aggregate(func, seed, filter) {
            this.steps.push({                
                func: func, 
                seed: seed,
                filter: filter || (x => true),
                type: 'aggregate'
            });
            return this;
        }

        changeData(func) {
            this.steps.push({
                func: func,
                type: 'changeData'
            });
            return this;
        }

        changeAggregated(func) {
            this.steps.push({
                func: func,
                type: 'changeAggregated'
            });
            return this;
        }

        emulators(func) {
            this.steps.push({
                func: func,
                type: 'emulators'
            });
            return this;
        }

        execute () {
            for(let step of this.steps) 
                this.applyStep(step);
            return this.aggregation;
        }

        applyStep (step) {

            if (step.type == 'changeAggregated') 
                this.aggregation = step.func(this.aggregation);
            
            else if (step.type == 'aggregate') {

                // Return 'null' instead of 'typeerror' (which 
                // is what Array.prototype.reduce returns)
                if (this.data.length == 0) {
                    this.aggregation = null;
                    return;
                }

                let v = 0; 

                // if the seed doesn't meet the filter, it's as
                // though no seed were set.
                if (step.seed === undefined || !step.filter(step.seed)) {
                    this.aggregation = this.data[0];
                    v = 1;
                } 
                else
                    this.aggregation = step.seed;

                for (v; v < this.data.length; v++) 
                if (step.filter(this.data[v])) 

                    // matches signature of first 'reducer' argument
                    // in Array.prototype.reduce
                    this.aggregation = step.func(
                        this.aggregation, // accumulator
                        this.data[v], // current value
                        v, // current index
                        this.data // source array
                    );

            }

            else if (step.type == 'changeData') 
                for (let rowIx in this.data) 
                    this.data[rowIx] = step.func(
                        this.data[rowIx], 
                        this.aggregation
                    );

            
            else if (step.type == 'emulators') 
                this.aggregation = aggregator.runEmulators(
                    step.func, 
                    this.data
                );

        }

    }

    // Aggregators such as 'sum' or 'avg' operate on
    // columnar data.  But the values passed to the
    // aggregators, such as 'x' in 'sum(x)' or 'avg(x)'
    // are point data.  'emulator' stores the row value,
    // but it also stores the name of the intented 
    // function (the one it emulates), for later loading
    // into a master aggregators object.  The name keeps
    // things cheap.  Obviously we don't want the whole
    // function for every row.  
    //
    // TODO: Put in a reference to the function if I can
    // ensure it's static.
    aggregator.emulator = class {
        constructor(rowValue, funcName) {
            this.rowValue = rowValue;
            this.funcName = funcName;
        }
    }

    // 'emulatorsFunc' is what the user will pass in.
    aggregator.runEmulators = function (
        emulatorsFunc, 
        dataset
    ) {

        let chosenAggregators = {};

        for (let row of dataset) {

            let emulators = emulatorsFunc(row);

            for (let key of Object.keys(emulators)) {

                let isEmulator = emulators[key].funcName;

                if (!isEmulator) 
                    emulators[key] = $$.last(emulators[key]);

                if (!chosenAggregators[key]) 
                    chosenAggregators[key] = aggregators[emulators[key].funcName]();

                chosenAggregators[key].loadValue(emulators[key].rowValue);

            }

        }

        for (let key of Object.keys(chosenAggregators)) 
            chosenAggregators[key] = chosenAggregators[key].execute();

        return chosenAggregators;

    }

    // This is where you would want other developers to 
    // plug-in new functions.
    //
    // aggregators is an object of functions that return 
    // aggregators.  If it had direct aggregators, then
    // any repeated use of the same property (such as using
    // sum twice, would refer to the same aggregator instance).
    let aggregators = {

        first:  () => new aggregator().aggregate((a,b) => a, null, a => a != null),
        last:   () => new aggregator().aggregate((a,b) => b),
        sum:    () => new aggregator().aggregate((a,b) => a + b),
        count:  () => new aggregator().aggregate((a,b) => a + 1, 0),

        avg:    () => new aggregator()
                .emulators(v => ({ 
                    sum: $$.sum(v), 
                    count: $$.count(v) 
                }))
                .changeAggregated(agg => agg.sum / agg.count),

        mad:    () => new aggregator()
                .emulators(v => ({ avg: $$.avg(v) }))
                .changeData((dataRow,agg) => Math.abs(dataRow - agg.avg)) 
                .emulators(v => ({ avg: $$.avg(v) }))
                .changeAggregated(agg => agg.avg)

    }

    // Load emulators into $$ so that user calls $$.aggFunc(val)
    // instead of new aggregator.emulator(val, 'aggFunc');
    
        let $$ = {};

        for (let aggregatorName of Object.keys(aggregators))
            $$[aggregatorName] = 
                value => new aggregator.emulator(value, aggregatorName); 

    let dataset = [{ a: 1 }, { a: 2 }, { a: 3 }, { a: 4 }];

    let result = aggregator.runEmulators(
        row => ({ 
            x: row.a,
            sum: $$.sum(row.a),
            cnt: $$.count(row.a),
            avg: $$.avg(row.a),
            mad: $$.mad(row.a)            
        }),
        dataset
    );

    console.log({result})

</script>
</body>