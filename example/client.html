<script type='module'>

    import sample from '../src/samples/sampleData.client.js';

    async function getDbVersion(dbName) {
        return new Promise((res,rej) => {
            let dbOpenRequest = indexedDB.open(dbName);
            dbOpenRequest.onsuccess = event => {
                let db = event.target.result;
                let v = db.version;
                db.close();
                res(v);
            };
        });
    }

    async function upgrade (db, reset, deleteWhenNotInReset) { 

        let isObject = typeof reset === 'object' && Object.keys(reset).length > 0;

        let datasets = 
            reset === true ? sampleDataSets
            : isObject ? reset
            : typeof reset === 'string' ? { [reset]: sampleDataSets[reset] }
            : Array.isArray(reset) ? reset.reduce((a,b) => Object.assign(a, {[b.key]: b.data}), {})
            : null;
            
        let keyPaths = 
            reset === true ? Object.keys(sampleDataSets).map(key => ({ [key]: 'id' }))
            : isObject ? Object.keys(datasets).reduce((a,b) => Object.assign(a, {[b.key]: 'id' }), {})
            : typeof reset === 'string' ? { [reset]: { [key]: 'id' } }
            : Array.isArray(reset) ? reset.reduce((a,b) => Object.assign(a, {[b.key]: b.keyPath}), {})
            : null;

        let deleteKeys = 
            deleteWhenNotInReset 
            ? [...db.objectStoreNames]
            : Object.keys(datasets);
            
        for (let key of deleteKeys) { 
            if ([...db.objectStoreNames].indexOf(key) == -1)
                continue;
            console.log(`deleting ${key}`);
            await db.deleteObjectStore(name);
        }

        for (let key of Object.keys(datasets)) { 

            console.log(`creating ${key}`);

            // if the first row of the store contains the expected key, 
            // then no autoincrement, otherwise yes.
            let store = await db.createObjectStore(key, {
                keyPath: keyPaths[key],
                autoIncrement: datasets[key].length > 0 && !Object.keys(datasets[key][0]).includes(keyPaths[key])
            });

            for (let row of datasets[key]) 
                store.put(row);

        }

    }

    async function openDb(
        
        dbName, 
    
        // omit to do no resets, 
        // pass true to reset from sampleData,
        // pass an {object} of key:data's to reset to that database
        // pass an [{key,keyPath,data}] to reset to that database with keypaths
        // pass a 'key' to reset only that key from sampleData          
        reset = false,

        // set to true to delete any dataset not represented in reset
        deleteWhenNotInReset = false 
        
    ) {
        
        let fullReset = reset === true && deleteWhenNotInReset;

        if (fullReset)
            await indexedDB.deleteDatabase(dbName);

        let version =
            fullReset ? 1 
            : reset ? await getDbVersion(dbName) + 1
            : undefined;

        return new Promise((res,rej) => {
            let dbOpenRequest = indexedDB.open(dbName, version);
            dbOpenRequest.onsuccess = event => res(event.target.result);
            dbOpenRequest.onupgradeneeded = 
                event => upgrade(event.target.result, reset, deleteWhenNotInReset);
        });

    }

    console.log(
        openDb('sampleData', { new: [{a: 'eigh', b: 'bee'}] })
    );


/*
    import sample from "../dist/sampleData.client.js";
    import sampleIdb from "../dist/sampleData.idb.js";
    import $$ from "../dist/FluentDB.client.next.js";

    let result = $$({
        sam: $$.idb('sampleData'),
        o: sample.orders,
        p: sam => 'products',
        c: sample.customers,
        pc: sam => 'potentialCustomers',
        s: sam => 'shoplifters' 
    })
    .group(o => o.customer) // if you don't group, '.reduce' will still output an array (with one item)
    .reduce(o => ({
        customer: $$.first(o.customer), 
        speed: $$.avg(o.speed),
        rating: $$.avg(o.rating),
        speed_cor: $$.cor(o.speed, o.rating)
    }))
    .test('groupReduce', o => o, data => {
        let row0 = prop => Math.round(data[0][prop] * 100) / 100;
        return data.length == 3
            && row0('rating') == 58.29
            && row0('speed') == 4.57
            && row0('speed_cor') == 0.74;
    });

    console.log(result);
*/

/*
    fetch('getMongo')
    .then(response => response.json())
    .then(json => console.log(JSON.stringify(json)))
    .catch(e => console.log({e}));
*/

</script>

